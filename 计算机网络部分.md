# 一、HTTP
##  1.GET和POST请求的区别

GET和POST是HTTP协议两种最常见的请求，它们在发送数据到服务器请求资源时有以下区别：

1.数据传输方式

- GET请求通过URL传输数据，数据附加在URL之后，一般形式：URL+?:key1=value1&&key2=value2，用户可见
- POST请求把数据放在HTTP消息的消息体（Body）里，一般对用户不可见，但这允许传输更大的数据

2.数据长度限制

- GET请求由于把数据附加在URL后，所以数据长度受URL长度所限，通常限制在2048个字符内
-  POST请求没有长度限制，理论上可以传输大量数据

3.安全性

- GET请求的数据是所有人可见的，会显示在URL中，所以不太安全，不适合传输敏感信息
- POST请求相对更安全，因为它不会显示在URL中，但是通过网络抓包工具还是能查看到

4.缓存

- GET请求能够被缓存，且能通过浏览器前进，后退访问，可以保存在浏览器历史记录中，能够被书签
- POST请求不能够被缓存，不会保留在历史记录中，也不能通过前进后退按钮访问，不能够被书签

5.幂等性

- GET请求是幂等的，多个相同的GET请求返回相同的结果，也就是多次访问不会改变资源的状态
- POST请求通常不是幂等的，它用于创建或更改资源，因此多次发送相同的POST请求可能每次都会有副作用

6.用途

- GET请求用来请求服务器发送资源，例如页面，图像，数据等
- POST请求用来提交表单数据，上传文件，或者通过API与服务器进行交互时创建资源和更新资源


##  2.POST和PUT请求的区别
1.用途

- POST请求常用于创建新的资源，当你不知道新的资源的URI想让服务器帮你创建一个时，使用POST。除了创建资源，它也可以用于出发操作或函数
- PUT请求通常用于更新已存在的资源，或者创建一个已知URI的新资源，如果你想替换目标资源的所有当前表示，用PUT

2.幂等性

- POST是非幂等的，意味着多次相同的POST请求，可能每次都会在服务器上生成新的资源
- PUT是幂等的，意味着多次执行相同的PUT请求，服务器上的资源情况不变

3.服务端的操作

- POST请求，它请求的结果通常是创建一个或多个新资源，返回时包含新资源的URI
- POST请求是将服务器上的目标资源与请求的内容进行替换

4.客户端提供的数据

- POST请求中，数据被视为新资源的一个整体，客户端不需要提前知道资源的URI，由服务端来创建
- PUT请求中，客户端指明了要创建或更新资源的URI。请求的数据体是对服务端URI的完整替代。

## 3.常见的HTTP请求头和响应头
HTTP请求头和响应头是HTTP消息的一部分，它们携带额外的信息（如客户端或服务器的信息、资源的元数据等）以帮助请求或响应

常见的HTTP请求头：

    1.Accept - 指定客户端能够接收的内容类型，如Accept:text/html
    2.Accept-Encoding - 指定客户端支持的内容编码类型，比如gzip或deflate
    3.Authorization - 包含凭证信息，通常用于服务器认证
    4.Cache-Control - 指示请求的缓存机制，比如Cache-Control: no-cache
    5.Content-Length - 请求消息体的长度
    6.Content-Type - 请求主体的MIME类型，例如Content-Type: application/json
    7.Cookie - 存放与服务器交互的cookie
    8.Host - 指定请求的服务器的域名和端口号
    9.User-Agent - 包含了有关客户端软件的信息，如浏览器类型和版本
    10.Referer - 表示发送请求的页面的地址
    11.Origin - 表明预期请求发起的源

常见的HTTP响应头

    1.Access-Control-Allow-Origin - 指定哪些网站可以参与跨域资源共享（CORS）
    2.Cache-Control - 指示响应的缓存机制
    3.Content-Encoding - 应用于响应主题的编码方式
    4.Content-Length - 响应消息体的长度
    5.Content-Type - 响应主题的MIME类型
    6.Set-Cookie - 告诉客户端保存一个cookie
    7.Date - 发送响应的日期和时间
    8.ETag - 资源的特定版本标识，用于比较和缓和
    9.Expires - 指定响应内容过期的时间
    10.Location - 用于重定向指向新的URL
    11.Server - 包含有关服务器软件的信息

##  4.常见的HTTP请求方法
- GET:请求指定的页面信息，并返回实体主体
- HEAD:和GET方法类似，但不会返回实体主体，只返回头信息
- POST:用于将客户端数据发送到服务器，比如表单提交
- PUT:从客户端向服务器传送的数据取代指定的文档的内容
- DELETE:请求服务器删除指定的页面
- PATCH:用于对已知资源进行局部更新
- OPTIONS:用于获取目的资源所支持的通信选项
- CONNECT:将连接改为管道方式的代理服务器
- TRACE:回显服务器收到的请求

##  5.常见的HTTP响应码

- 1xx(信息性状态码):接受的请求正在处理
- 2xx(成功状态码):请求正常处理完毕
  * 200 OK:请求成功
  * 201 Created:请求成功并且服务器创建了新的资源
  * 204 No Content: 请求成功但没有内容需要返回
- 3xx(重定向状态码):需要进一步的操作以完成请求
  * 301Moved Permanently:永久重定向
  * 302 Found:临时重定向
  * 304 Not Modified:资源未修改，可使用缓存的版本
- 4xx(请求错误状态码):请求含有语法错误或不能被执行
  * 400 Bad Request:服务器不理解请求的语法
  * 401 Unauthorized:请求需要用户的认证。
  * 403 Forbidden:服务器理解请求客户端的请求，但是拒绝执行此请求
  * 404 Not Found:服务器找不到请求的网页
- 5xx(服务器错误状态码):服务器处理请求出错
  * 500 Internal Server Error:服务器内部错误，无法完成请求。
  * 501 Not Implemented:服务器不支持请求的功能，无法完成请求。
  * 503 Service Unavailable:服务器暂时的无法处理请求(可能是过载或维护) 

##  6.OPTIONS请求方法及使用场景
OPTIONS方法是用于请求获得由Request-URI标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。

OPTIONS请求方法的主要用途有两个:
  - 获取服务器支持的所有HTTP请求方法；
  - 用来检查访问权限。例如：在进行CORS跨域资源共享时，对于复杂请求，就是用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。


##  7.HTTP1.0和HTTP1.1之间有哪些区别

1.连接重用
  - 在HTTP/1.0中，默认情况下，每个请求/响应对都要打开一个新的连接，并在响应后立即关闭。这意味着每个请求都会经历完整的连接建立、数据传输和连接断开的过程，导致额外的延迟
  - HTTP/1.1引入了持久连接(也称为连接重用或Keep-Alive)。默认情况下，连接在发送请求后保持打开状态，可以被后续的请求服用，除非明确要求关闭。这减少了连接和断开的开销，提高了网络的传输效率

2.管道化

  - HTTP/1.1新增了对请求的管道化处理。在同一个TCP连接中，客户端可以在等待第一个请求的回复时发送后续的请求。这可以进一步降低延迟
  - HTTP/1.0不支持管道化，每一个请求都需要等到前一个响应后才能发送

3.分块传输编码

  - HTTP/1.1支持分块传输编码，允许服务器在发送完整响应之前开始传输响应。这对于动态生成的内容非常游泳，因为服务器可以传输数据的同时继续处理剩余的数据
  - HTTP/1.0需要服务器在发送响应之前确定整个响应的内容长度

4.缓存控制

  - HTTP/1.1引入了更复杂的缓存控制机制，如ETag、If-Modified-Since、If-Unmodified-Since、If-Match、If-None-Match等头部字段用来更有效地控制对资源的缓存。
  - HTTP/1.0的缓存控制较为基本，主要使用Pragma和Expires头部字段

5.Host头部

  - HTTP/1.1引入了Host头部，允许多个域名(虚拟主机)在相同的IP地址和端口上共存。HTTP/1.1的请求被要求包含Host头部
  - 在HTTP/1.0中，因为没有Host头部，每个服务的IP地址/端口组合只能对应一个域名

6.请求方法和状态码

  - HTTP/1.1新定义的请求方法包括：
    * OPTIONS
    * PUT
    * DELETE
    * TRACE
    * CONNECT
  - 响应码略

7.对Keep-Alive的理解

  Keep-Alive是HTTP/1.1协议的一个机制，用于保持连接持续活动，允许在同一个TCP连接中发送和接收多个HTTP请求/响应，而不是每次请求/响应都重新建立连接

  在HTTP/1.0中，每完成一个请求/响应周期，连接默认就会关闭，这称为"非持久连接"。每次HTTP交互都需要进行新的TCP三次握手，这增加了延迟和网络负担。随着网络活动的增多，这个问题变得尤为突出。

  为了解决这个问题，HTTP/1.1引入了持久连接(也称为连接复用或Keep-Alive)，特点如下:

  - 减少延迟:避免了因为建立新的TCP连接而产生的延迟(TCP三次握手)
  - 减少资源消耗:复用连接减少了服务器和客户端维护大量连接的需要，从而节省了资源
  - 增加吞吐量:因为连接维持开启，更快的开始数据传输，整体网络吞吐量得到提升

Keep-Alive在HTTP头部使用的两个字段是Connection和Keep-Alive。Connection:Keep-Alive指示这个连接将保持活动状态;Keep-Alive头部可以包含额外的指令，如最长持续时间(timeout)和最大请求数(max),指示连接应保持打开状态的时间和连接上可以发送的最大请求数量。

最终，服务器和客户端可以协商决定是否使用Keep-Alive,以及它的行为。如果任一方决定关闭连接，它们可以发送Connection:close头部来结束连接。

需要注意的是，在现代HTTP实践中，虽然Keep-Alive特性大大提高了HTTP/1.1的性能，但它也引入了某些问题，如服务器端需要处理大量半开连接(half-open connections)导致的资源消耗。随着HTTP/2和HTTP/3的发展，更高效的连接管理策略被采用,例如HTTP/2的多路复用(multiplexing)允许在单个连接上几乎同使发送多个请求和响应

##  8.HTTP请求报文的是什么样的？
HTTP请求报文是由客户端发送给服务器以发起请求的信息。一个标准的HTTP请求报文由三个主要部分组成:请求行、请求头部(Headers)和请求体(Body,不是所有请求都有)

1.请求行:
  - 包括请求方法、请求的资源路径(URL或URI的一部分)和HTTP协议的版本。
  - 例如:GET /index.html HTTP/1.1

2.请求头部:
  - 包含了描述请求的Metadata，可以有很多行，每个头部详细描述了请求的信息、客户端信息等。
  - 例如：
  ```     Host: www.example.com
     User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
     Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
     Accept-Language: en-US,en;q=0.5
     Accept-Encoding: gzip, deflate
     Connection: keep-alive
     Cookie: sessionId=abc123
  ```
3.空行

  - 请求头部和请求体之间有一个空行，表示请求头部的结束

4.请求体(可选)

  - 不是所有的请求都有请求体，通常只有POST和PUT这类请求会包含请求体
  - 包含了发送给服务器的数据，通常是在POST请求中提交表单数据时使用

##  9.HTTP响应报文是什么样的？
HTTP响应报文是服务器在收到客户端的HTTP请求后，返回给客户端的信息。一个标准的HTTP响应报文由三个主要部分组成:状态行、响应头部(Headers)、响应体(Body,不是所有响应体都有)。

1.状态行
  - 包括HTTP协议的版本、状态码及其原因短语。
  - 例如:HTTP/1.1 200 OK

2.响应头部
  - 包含了描述响应的Metadata,可以有多个头部行,每个头部详细描述了服务器的信息、响应体的内容类型和长度、缓存控制等
  - 例如:
```
     Date: Wed, 21 Oct 2020 07:28:00 GMT
     Server: Apache/2.4.1 (Unix)
     Content-Type: text/html; charset=UTF-8
     Content-Length: 88
     Connection: close
```
3.空行
  - 响应头部和响应体之间有一个空行,表示响应头部的结束

4.响应体(可选):
  - 包含服务器对请求的回应数据;比如请求网页时,它会包含HTML内容。
  - 例如:网页的HTML,图片的二进制数据,或者是JSON/XML数据等

下面是一个HTTP响应报文的例子:
```
HTTP/1.1 200 OK
Date: Sun, 10 Oct 2020 14:28:00 GMT
Server: Apache/2.4.1 (Unix)
Last-Modified: Sat, 09 Oct 2020 14:28:00 GMT
Content-Type: text/html; charset=UTF-8
Content-Length: 88
Connection: close

<html>
<head>
  <title>An Example Page</title>
</head>
<body>
  Hello World, this is a very simple HTML document.
</body>
</html>
```

##  10.HTTP协议的优点和缺点
HTTP的优点包括:

1.简单易懂:HTTP的请求和响应模型简单明了,便于理解和使用,这使得它容易被广泛采用

2.灵活:HTTP允许传输任何类型的数据对象,只要服务端和客户端知道如何处理这些数据即可

3.无状态性:HTTP是无状态的协议,服务器不保存关于客户的任何数据。这种设计使得服务器更容易管理,因为不需要维护客户的连接状态,可以更好地服务于更多的客户

4.可扩展性:HTTP头部允许传递额外的信息,而且协议的标准允许自定义头部,为协议的扩展提供了便利

5.与网络基础设施兼容良好:HTTP在80端口工作,易于通过防火墙和代理,兼容性强

6.支持分布式环境:HTTP支持代理服务器和缓存服务器,可以减轻主服务器的负担,提高请求处理速度

HTTP的缺点包括:

1.不安全:HTTP本身不提供加密功能，数据以明文方式传输，因此容易被截获和篡改。虽然HTTPS(加密的HTTP)可以解决这个问题，但还是有很多网站在使用不安全的HTTP

2.无状态性也可能是缺点:虽然无状态设计使得服务器简单，但是它也限制了无法保持交互状态。例如，无法在不使用诸如Cookies或会话跟踪工具的情况下记住用户的信息

3.TCP连接的使用:每次HTTP请求都需要建立一个TCP连接(在HTTP/1.1中，这个问题可以通过持久连接进行一定程度的缓解)，这个过程可能导致相对较高的延迟，并且增加服务器端处理链接的复杂性

4.性能问题:HTTP/1.1虽然支持持久连接，但每个传输仍然需要一个完整的请求响应周期。HTTP/2通过引入流、多路复用等特性来提高性能，但是这些特性不是HTTP协议原始版本中的

5.数据冗余:HTTP的头部信息在每次请求时几乎都是重复的，特别是在一系列的请求中，这增加了不必要的数据传输量，特别是在移动网络较慢的情况下

##  11.当在浏览器中输入 Google.com 并且按下回车之后发生了什么？

1.域名解析

  - 浏览器首先检查缓存是否有"google.com"的IP地址(包括浏览器缓存、系统缓存、路由器缓存)。
  - 如果没有缓存，请求会发送到DNS服务器来解析域名"google.com"到对应的IP地址

2.建立TCP连接
  - 浏览器利用解析得到的IP地址，发起到Google服务器的TCP连接请求，这通常涉及到一个三次握手过程

3.发送HTTP请求
  - 一旦TCP连接建立，浏览器会构建HTTP请求并通过TCP连接发送给Google服务器
  - 请求包括一个请求行(通常是GET方法)，请求头部(如User-Agent,Accept-Language等)，以及必要的cookie数据

4.服务器处理请求并发送HTTP响应
  - Google的服务器接受请求后处理，然后返回一个HTTP响应。
  - 响应码通常包括状态码(如200 OK),HTTP头部信息，和请求的数据(即Google首页的HTML)

5.浏览器渲染页面
  - 浏览器接收到HTML响应后开始解析并构建DOM树
  - 浏览器处理HTML中的CSS和Javascript，并可能发出额外的HTTP请求去获取诸如图片、CSS文件、javascript文件等其他资源

6.关闭TCP连接
  - 页面加载完成后，TCP连接可以通过四次挥手过程关闭，也可能会根据HTTP头部信息中的Connection字段保持打开以供后续请求复用(Keep-Alive)

7.用户看到完全渲染的页面
  - 最终用户会在浏览器中看到完全渲染的Google首页


##  12.URL有哪些组成部分
URL(统一资源定位器)由若干个部分组成，用于指定互联网上资源的位置。一个典型的URL可能包含以下几个组成部分

1.协议(Scheme):
  - 指定了访问资源所使用的协议类型，例如http、https、ftp等
  - 例如:https://

2.子域名(Subdomain)
  - 通常是对网站的一个子集或者子分类
  - 例如:subdomain.example.com中的subdomain

3.域名(Domain)
  - 表示资源所在的服务器的名称，通常是该网站的可读名称
  - 例如: example.com中的example

4.顶级域名(TLD)
  - 域名的最后部分，表示域名所属的顶级域(如.com、.org、.net等)

5.端口(Port)(可选)
  - 用于访问资源的服务器端口号，如果省略，则使用协议的默认端口
  - 例如:80、443

6.路径(Path)
  - 表示资源在服务器上的具体位置。对应着文件系统中的路径，但也可能是抽象的，由服务器解释
  - 例如:/folder/page.html

7.查询字符串(Query)(可选)
  - 以问号(?)开头，后面跟着一个或多个参数。用于传递额外信息给服务端
  - 例如:?key1=value1&key2=value2

8.片段(Fragment)
  - 以井号(#)开头，指定网页中的一个片段或位置，常用于定位到页面的特定部分
  - 例如:#section1


##  13.HTTP1.1和HTTP2.0的区别
1.二进制协议
  - HTTP/1.1是一个文本协议，请求和响应中的头部信息都是文本形式
  - HTTP/2引入了二进制格式，使得解析更加高效，减少了错误，并且减少了不必要的网络开销

2.多路复用
  - 在HTTP/1.1中，每个请求需要一个TCP连接，这导致了连接数量的增加，并容易引起队头阻塞问题
  - HTTP/2通过使用单一的TCP连接进行多个请求和响应的多路复用，消除了队头阻塞，且更有效地使用网络资源

3.头部压缩
  - HTTP/1.1不包含头部压缩功能，导致头部携带的数据往往很大
  - HTTP/2使用HPACK压缩机制来减小头部大小，减少网络传输数据量

4.服务器推送
  - HTTP/1.1不支持服务器推送，服务器只能对客户端请求作出响应
  - HTTP/2允许服务器无需客户端请求即可发送资源，这样可以减少延迟，并充分利用连接的性能，提前发送客户端可能需要的资源

5.流优先级
  - HTTP/1.1不支持指定请求的优先级
  - HTTP/2支持为请求设置优先级，服务器可以根据优先级来决定先处理哪个请求，使得资源调度更加高效

6.安全性
  - 虽然HTTP/1.1支持HTTPS，但HTTP/2的规范建议使用TLS加密传输，以提高安全性
  - 许多浏览器实现HTTP/2时，实际上已经要求必须与TLS一起使用

##  14.HTTP2的头部压缩算法是怎样的？
HTTP/2使用称为HPACK的头部压缩算法来减少传输中头部数据的大小。HPACK压缩算法针对HTTP头部的特性进行了优化，并且通过以下几个主要的机制来减少需要传输的头部字节:

1.静态表
  - 用于保存常见的HTTP头部名称和值。这个表时预定义的，并且在客户端和服务器之间共享。它包含了一些最常用的HTTP头部字段，如:method,:path,:scheme,:status及常用值

2.动态表
  - 在连接期间，客户端和服务器可以通过HPACK将头部名称和值添加到动态表中，这样在后续的请求和响应中就可以通过索引来引用这些条目，而不是再次发送整个名称和值

3.霍夫曼编码
  - 核心数据使用霍夫曼编码进行压缩。霍夫曼编码是一种统计编码，它以常见的字符分配较短的编码，为不常见的字符分配较长的编码

4.索引表示
  - 当使用索引访问静态表或动态表中的头部表示时，只需要发送一个小的索引值

5.字面量表示
  - 如果头部不在静态表和动态表中，它可以以字面量形式发送，即使是字面量形式的头部也可以选择霍夫曼编码进行压缩

6.增量更新
  - 动态表中的头部可以通过请求进行增量更新，这意味着随着时间的推移，对头部进行的更改可以通过传输最小的增量进行


##  15.说一下HTTP 3.0
HTTP/3是互联网工程任务组(IETF)正在开发的HTTP协议的最新版本。它建立在先前版本的基础之上，并引入了一些关键的改进以进一步提升网络性能和可靠性。最显著的变化是HTTP/3不适用TCP作为传输层协议，而是使用QUIC(Quick UDP Internet Connections)

以下是HTTP/3的一些重要特征

1.基于QUIC协议
  - HTTP/3使用基于UDP的QUIC协议。QUIC解决了TCP在建立连接、传输可靠性、拥堵控制和多路复用方面的一些问题

2.减少连接延迟
  - QUIC通过减少握手过程(通常只需要单个往返时间)来显著减少连接的建立时间。这对于移动网络或需要启动多个连接进行资源获取的情况非常有益

3.连接迁移
  - QUIC具备连接迁移的特性，这意味着即使网络环境改变(例如切换Wi-Fi或移动网络)，连接状态也可以保持稳定，减少中断

4.独立流的拥堵控制
  - QUIC将不同的请求分散在独立的流上，并且每个流有自己的流控和拥堵控制。与HTTP/2不同的是，一个流的延迟不会影响其他流

5.内置加密
  - QUIC集成了TLS 1.3加密，保护用户数据，防止中间人攻击，并且加密的握手过程与QUIC的快速连接建立相结合

6.零RTT连接复用
  - 对雨之前已经建立过的连接，QUIC支持零往返时间(0-RTT)重启，这可以在重连时进一步减小延迟

##  16.HTTP和HTTPS协议的区别
HTTP和HTTPS的主要区别在于安全性方面。它们都用于在客户端与服务器之间传输数据，但使用不同的方式连接和传输数据。以下是HTTP和HTTPS的核心区别：

1.安全性
  - HTTP本身不包含任何加密机制，所以传输的信息(包括网址、传输的内容、用户凭据等)都是明文的，任何人在途中拦截流量都能直接读取这些信息。
  - HTTPS在HTTP的基础上增加了SSL/TLS(安全套接字层/传输层安全)加密，这个加密层可以保护传输过程中的数据不被第三方轻易截获和篡改

2.端口号
  - HTTP服务默认端口时80
  - HTTPS服务默认端口号时443

3.URL前缀
- HTTP网站的URL以http://开头
- HTTPS网站的URL以https://开头

4.证书要求
  - HTTP不需要证书
  - HTTPS需要SSL/TLS证书来验证服务器的身份，并用于加密数据。这些证书需要由信任的证书颁发机构(CA)颁发

5.性能
  - 由于数据加密和解密过程中需要消耗一定的计算资源，HTTPS在性能上可能比HTTP慢一些

# 二、HTTPS

##  1.什么是HTTPS协议？
HTTPS是HTTP协议的安全版本。HTTP协议(超文本传输协议)是用于从服务器传输超文本到本地浏览器的传递协议，但它不加密，意味着第三方可能窃听、篡改或伪造请求

**HTTPS协议的基本概念**：

1. **安全性**：HTTPS使用SSL或TLS(传输层安全协议)在客户端和服务器之间建立加密链接，确保传输的数据在网络中为加密形态，从而提供数据传输的安全性
2. **加密**：它通过加密传输的数据来保护通信免受监听和中间人攻击，这意味着用户与网站之间交换的数据无法被未授权者阅读
3. **完整性**：确保数据在传输过程中不被篡改
4. **认证**：通过证书验证服务端的身份，避免用户流量被重定向到恶意站点。

**如何工作**：

HTTPS在HTTP上叠加了一层SSL/TLS加密层工作流程如下：

1. **建立连接**：当用户尝试通过HTTPS访问网站时，服务器会将其SSL/TLS证书发送给用户的浏览器
2. **验证证书**：浏览器将检查该证书的有效性，包括该证书是否受信任的证书颁发机构签发，是否有效，以及该证书的域名是否和请求的域名相匹配
3. **密钥交换**：一旦证书验证成功，浏览器和服务器之间回建立一个加密的会话，这涉及到一个密钥交换过程来建立一个对称加密
4. **加密通信**：密钥交换完成后，浏览器与服务器之间的所有通信都将通过这个密钥加密和解密，确保传输的数据安全


##  2.TLS/SSL的工作原理

TLS(传输层安全)和SSL(安全套接字层)是确保网络通信安全的协议，TLS是SSL的后续版本，它们通过以下步骤协同工作来保护数据安全：

1. **客户端发起连接**：客户端(如web浏览器)通过HTTPS请求与服务器建立安全连接
2. **服务器响应**：服务器接收到客户端请求后，将它的SSL/TLS证书发送给客户端。证书包含服务器的公钥以及证书颁发机构(CA)的签名
3. **客户端验证证书**：客户端验证服务器证书的合法性。包括证书是否未过期、域名是否一致、证书是否由可信任的CA签发
4. **密钥交换**：
- **适用TLS1.2及之前的版本**：
  - 客户端使用服务器证书中的公钥加密一个随机生成的对称加密密钥(会话密钥)，然后将加密后的密钥发给服务器
  - 服务器使用自己的私钥解密会得到会话密钥
- **使用TLS1.3的版本**：
  - 它使用零知识证明和一系列密钥衍生步骤来建立共享的密钥，而不是发送一个加密的密钥

5. **安全的会话**：现在服务器和客户端都拥有同一个会话密钥，他们就用它进行对称加密，可以开始安全地交换信息了
6. **加密数据传输**：利用会话密钥，双方交换的所有信息都会被加密后发送，并在接收端被解密。这确保了传输过程中的数据的机密性和完整性

**TLS/SSL握手详解**

业界已经普遍采用了TLS协议，而SSL已经不再推荐使用。在TLS握手过程中，包含了以下重要的步骤：

- **CilentHello**:客户端发送一个消息，指出它支持的TLS版本，加密套件列表(Encryption Suites)，以及其他一些会话设置
- **ServerHello**：服务器选择客户端提供的选项列表中的一个，并通知客户端该会话将使用的选项
- **Certificates & Key Exchange**:服务器发送证书并可能包含一些密钥交换数据。客户端可能也会发送密钥交换数据
- **Secure Key Determination**:客户端和服务端利用交换的密钥信息来生成对称密钥，通常是使用Diffie-Hellman密钥交换算法或类似方法，确保双方都能得到相同的密钥
- **Finished**：双方交换已完成的消息，这标志着握手的结束并验证了会话的开始

TLS协议的这些步骤提供了一种安全的方式来验证身份，建立加密的会话，并对数据进行加密， 从而确保了数据的机密性和完整性


##  3.数字证书是什么？
数字证书是一种用于确认持有者身份的电子文件，通常在网络交易和通讯中用于增加安全性。数字证书基于公钥加密的原理，由认证机构(CA)颁发，用以证明公钥的所有权以及证书持有人的身份信息

**数字证书包含的关键信息**：

- **公钥**：证书所有者的公钥，用于加密向其发送的消息或验证其签名的消息
- **持有者信息**：证书持有者的身份信息，如个人、公司或组织名称
- **颁发机构**：颁发和签发证书的证书颁发机构(CA)信息。
- **有效期**：证书的有效期限，证书过期后将不可信任
- **证书序列号**：证书的唯一序列号，用于识别证书
- **数字签名**：证书颁发机构的数字签名，证明证书的真实性

**数字证书的原理和作用**：

当服务器向客户端展示其数字证书时，客户端软件(如Web浏览器)会自动检查证书的有效性。这包括证书是否由客户端信任的CA签发，是否未过期，以及是否被吊销

数字证书支撑了HTTPS协议，确保了通信双方能够确认对方的身份，防止了中间人攻击。通过数字证书提供的公钥，客户端可以与服务器安全地建立加密通道，并确保信息在传输过程中的安全

**数字证书的适用场景**：

- **HTTPS**:在Web服务器与客户端浏览器之间建立安全通信时使用SSL/TLS证书
- **电子邮件**：确保邮件内容的来源真实性和内容完整性
- **代码签名**：证明软件发布者的身份，并确保代码自发布以来未被修改
- **VPN**：在远程工作时，用于建立安全的网络连接

数字证书的核心价值在于它提供了一种安全的身份验证方式，增强了数据通讯和电子交易的信任度和完整性

##  4.HTTPS通信（握手）过程
HTTPS通信过程涉及一个握手阶段，该阶段建立了加密的通信通道，并验证了服务器的身份。以下是一个简化的握手过程

1. **客户端Hello(ClientHello)**

客户端发起通信，通常是当用户尝试建立HTTPS连接时。客户端Hello消息包括：

 - 支持的TLS版本
 - 支持的加密套件(如RSA, AES等)
 - 一个客户端生成的随机数(Client Random)，用于后续的密钥生成

2. **服务端Hello(ServerHello)**

服务器收到客户端的Hello消息后，会选择一个双方都支持的加密方法，并发送给客户端：
 - 选择使用的TLS版本
 - 选择使用的加密套件
 - 一个服务器生成的随机数(Server Random)

3. **服务器证书和密钥交换**

服务器将自己的数字证书发送给客户端。数字证书中包含了服务器的公钥。同使，服务器也可能发送一些必要的密钥交换信息

4. **客户端验证证书**

客户端验证服务器提供的证书是否有效，检测给出的证书受否是由受信任的CA颁发，证书是否未过期或已吊销，以及证书的公钥是否匹配域名

5. **密钥交换**

客户端使用证书中的公钥加密一个预主密钥(Pre-Master Secret)并发送给服务器。然后，客户端和服务器都是用Client Random, Server Random以及Pre-Master Secret通过一个固定的算法生成相同的会话密钥

对于TLS1.3版本，密钥交换过程使用Diffie-Hellman算法，不再需要直接传输预主密钥，增强了过程的安全性

6. **终结握手并验证**

客户端发送一个消息通知服务器将在随后的通信中使用会话密钥进行加密。此消息同时会包含之前所有通信内容的摘要，以供服务器验证。

服务器会送一个类似的消息给客户端，客户端验证摘要无误后，握手阶段结束

7. **加密通信**

握手成功之后，客户端和服务器使用会话密钥来加密他们之间的通信，保证数据隐私和完整性

这个过程确保了客户端与服务器之间数据传输的安全性和可靠性，同时也保护了用户的隐私。握手阶段为双方提供了通信所需的共享会话密钥，而不会暴露密钥信息给窃听者

##  5.HTTPS的优缺点
HTTPS协议，在提高网络传输安全性方面是非常关键的，它在HTTP的基础上通过SSL/TLS进行加密通信。以下是HTTPS的一些主要优缺点：

**HTTPS的优点**：

1. **加密**：HTTPS加密传输的数据，防止数据被窃听。即使数据被截获，也无法轻易被解析
2. **数据完整性**：HTTPS能够验证数据在传输过程中没有被修改，确保数据的完整性
3. **认证**：HTTPS提供了身份验证，确保客户端与服务器通信的真实性，防止中间人攻击(MITM)
4. **SEO改进**：搜索引擎(如Google)倾向于对HTTPS站点进行更好地排名，从而有助于搜索引擎优化(SEO)
5. **信任和信誉**：对于用户来说，浏览器中的锁标志以及HTTPS前缀增强了对网站的信任
6. **满足法规要求**：某些法规要求对敏感数据进行加密传输，比如支付卡行业数据安全标准(PCI DSS)

**HTTPS的缺点**

1. **性能开销**：加密和解密数据需要额外的服务器资源，可能会导致页面加载时间稍微增加
2. **证书成本**：虽然有的机构如Let's Encrypt提供免费证书，但某些证书(尤其是高级证书，例如EV SSL)可能很昂贵
3. **配置和管理**：安装和配置SSL/TLS证书，以及管理续期、撤销等可能比较复杂
4. **兼容性问题**：某些老旧的设备或浏览器可能不支持SSL/TLS协议，导致网站不可访问
5. **中间件和缓存问题**：由于HTTPS加密了数据，一些针对HTTP设计的基础架构、中间件、CDN和缓存策略可能需要调整以支持HTTPS


##  6.HTTPS是如何保证安全的？
HTTPS通过以下几个关键技术来保证数据传输的安全：

1. **加密**：客户端与服务器之间交换的数据都通过加密算法加密，这可以防止中间人能够窃听交流内容。即便数据被拦截，由于它是加密过的，未经授权的第三方也无法理解数据的真实内容
2. **身份验证**：HTTPS使用SSL/TLS证书提供身份验证，该证书由第三方信任机构(CA)签发。当用户访问一个HTTPS网站时，浏览器会验证服务器的SSL/TLS证书，确保用户与真正的服务器进行通信，而不是一个伪装的网站。这减少了钓鱼攻击和中间人攻击的风险
3. **完整性**：加密过程还包括完整性检查，确保在数据传输过程中未被篡改。这是通过使用消息摘要或散列算法实现的，任何对数据的修改都会导致计算出的散列值不匹配，从而检测到篡改
4. **安全握手**：在HTTPS通信开始时，客户端和服务器之间进行一个安全握手过程，这涵盖了证书验证、密钥交换等过程。握手协商出一个会话密钥，该密钥用于当前连接期间加密所有传输的数据
5. **密钥交换**：使用安全的密钥交换算法(如Diffie-Hellman)，即便交换数据过程被窃听，也无法得知最终协商的密钥，因为它们基于一种只有参与方才能计算出共享密钥的数学难题
6. **安全协议**：SSL/TLS协议本身经过多年的发展，采用等多种加密技术与算法，保证只有对等方才能解密通信内容。此协议不断更新，淘汰了不安全的就算发，保持与现代密码学的同步


# 三、DNS协议介绍

##  1.DNS协议是什么
1. **概念**：DNS是域名系统(Domain Name System)的缩写，提供的是一种主机名到IP地址的转换服务，就是我们常说的域名系统。它是一个由分层的DNS服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP数串

2. **作用**：将域名解析为IP地址，客户端向DNS服务器(DNS服务器有自己的IP地址)发送域名查询请求，DNS服务器告知客户机Web服务器的IP地址


##  2.DNS同时使用TCP和UDP协议？

一般情况下，DNS查询主要使用UDP协议：

**UDP**：传统的DNS查询使用UDP协议，因为它更快。UDP是无连接的，执行简单的请求-响应模型，这使得DNS查询可以快速执行。由于大多数DNS响应数据包都非常小(典型的限制是512字节)，它们适合单个UDP数据包发送

但在某些情况下，DNS查询会使用TCP协议：

**TCP**:DNS通过TCP协议进行通信的情况包括但不限于：
- 当DNS响应数据超过UDP包的大小限制时(512字节，或者通过EDNS扩展后的4096字节)，就需要使用TCP了。TCP没有这样的数据包大小限制
- 在域传送(zone transfer)中，如AXFR和IXFR请求，通常使用TCP，因为这些请求通常涉及大量数据
- 如果DNS查询或响应在UDP中出现丢包情况，可能会尝试使用TCP重传

总的来说，DNS使用UDP来提供快速、效率高的查找服务，并在需要的情况下依赖TCP来确保数据的完整性和安全性。当今的DNS服务器和客户端都支持在UDP和TCP端口53上进行通信

##  3.DNS完整的查询过程

DNS服务器解析域名的过程：

1. 首先会在**浏览器的缓存**中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步
2. 将请求发送给**本地DNS服务器**，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
3. 本地DNS服务器向**根域名服务器**发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
4. 本地DNS服务器向**顶级域名服务器**发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
5. 本地DNS服务器向**权威域名服务器**发送请求，域名服务器返回对应的结果
6. 本地DNS服务器将返回结果保存在缓存中，便于下次使用
7. 本地DNS服务器将返回结果给浏览器

比如要查询www.baidu.com的IP地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的DNS服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责.com的顶级域名服务器的IP地址的列表。然后本地DNS服务器再向其中一个负责.com的顶级域名服务器发送一个请求，负责.com的顶级域名服务器返回负责.baidu的权威域名服务器的IP地址列表。然后本地DNS服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的IP地址列表


##  4.迭代查询与递归查询

DNS查询主要有两种模式：迭代查询和递归查询。两者之间的主要区别在于查询解析过程的不同

**递归查询**：

当一个客户端(例如计算机或者路由器)向DNS服务器发送一个递归查询请求时，这个服务器会负责处理整个查询过程，从根服务器开始一直到获得解析结果，中间过程对客户端是透明的。如果这个DNS服务器不具备请求的记录信息，它会作为客户端去请求上一级服务器，并将结果返回给原始请求者

**迭代查询**：

当一个DNS服务器接收到客户端的请求时，如果这个请求是一个迭代查询，服务器会提供最直接的答案。如果这个DNS服务器不具备解析的完成信息，它并不会去请求其他服务器，而是会告诉客户端下一个能够向其提供信息的服务器的地址。然后客户端会向这个新的服务器发起新的查询，这个过程会重复进行，直到得到最终结果


**示例对比**：

假设我们正在查找"www.baidu.com"的IP地址

1. **递归查询**：
   - 客户端向本地DNS发送一个递归查询请求
   - 本地DNS向跟服务器发送查询请求
   - 根服务器将对应域的顶级域(TLD)服务器地址返回给本地DNS
   - 本地DNS向TLD服务器发送查询请求
   - TLD服务器将对应域的权威名称服务器地址返回给本地DNS
   - 本地DNS向权威名称服务器发送查询请求
   - 权威名称服务器将"www.baidu.com"的IP地址返回给本地DNS
   - 本地DNS最后将这个IP地址返回给客户端

2. **迭代查询**:
  - 客户端向本地DNS发起一个迭代查询请求
  - 本地DNS向根服务器发送查询，根服务器返回TLD服务器地址
  - 客户端接着向TLD服务器发送查询，TLD服务器返回权威名称服务器地址
  - 客户端最后向权威服务器发送查询，权威名称服务器返回"www.baidu.com"的IP地址

##  5.迭代查询和递归查询的主要区别？

1. **请求者的角色**:
   - 在递归查询中，客户端请求DNS服务器解析域名，然后DNS服务器负责代为完成整个解析过程，最终将结果返回给客户端。客户端只需等待最终结果
   - 在迭代查询中，客户端向DNS服务器请求域名解析，如果DNS服务器中没有缓存结果，它会指示客户端下一步应该查询的服务器。客户端将继续向推荐的服务器发起请求，直到获得最终解析结果
2. **查询过程**
   - 递归查询通常由服务端向本地DNS服务器发起，本地DNS服务器要么直接回复(如果有缓存结果)，要么递归地从其他DNS服务器擦汗寻，直到得到答案
   - 迭代查询通常发生在DNS服务器之间，一个DNS服务器如根服务器、顶级域名(TLD)服务器或权威服务器会告诉请求服务器下一个应该查询的服务器，直到找到精确信息
3. **查询责任**
   - 在递归查询中，单个请求的DNS服务器负责整个域名解析过程
   - 在迭代查询中，最终的域名解析责任在客户端手中，DNS服务器只是逐步指导客户端应该到哪里去找信息
4. **执行效率**
   - 递归查询可能更消耗资源，因为DNS服务器要完成整个解析过程，可能需要多次查询其他服务器
   - 迭代查询有效地将查询责任分散到多个DNS服务器上，每个服务器处理请求并指向下一个服务器，消耗较少资源
5. **使用场合**
   - 递归查询通常在用户的设备上开始，例如你的个人电脑或手机发起的查询，因为用户期望DNS服务提供完整的解析结果
   - 迭代查询更常见于DNS服务器间的查询，这些服务器具备完成查询的知识和能力


##  6.DNS记录和报文

DNS服务器中以资源记录的形式存储信息，每一个DNS响应报文一般包含多条资源记录。一条资源记录的具体的格式为：（Name，Value，Type，TTL）

其中TTL是资源记录的生存时间，它定义了资源记录能够被其他的DNS服务器缓存多长时间。

常用的一共有四种Type的值，分别是A、NS、CNAME和MX，不同Type的值，对应资源记录代表的意义不同

- 如果Type = A，则Name是主机名，Value是主机名对应的IP地址。因此一条记录为A的资源记录提供了标准的主机名到IP地址的映射
- 如果Type = NS，则Name是个域名，Value是负责该域名的DNS服务器的主机名。这个记录主要用于DNS链式查询时，返回下一级需要查询的DNS服务器的信息
- 如果Type = CNAME，则Name为别名，Value为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名对应的规范主机名，从而告诉查询主机区查询这个主机名的IP地址。主机别名主要是为了通过给一些复杂的主机名提供一个便于记忆的简单的别名
- 如果Type = MX，则Name为一个邮件服务器的别名，Value为邮件服务器的规范主机名。它的作用和CNAME是一样的，都是为了解决规范主机名不利于记忆的缺点