# 一、HTTP
##  1.GET和POST请求的区别

GET和POST是HTTP协议两种最常见的请求，它们在发送数据到服务器请求资源时有以下区别：

1.数据传输方式

- GET请求通过URL传输数据，数据附加在URL之后，一般形式：URL+?:key1=value1&&key2=value2，用户可见
- POST请求把数据放在HTTP消息的消息体（Body）里，一般对用户不可见，但这允许传输更大的数据

2.数据长度限制

- GET请求由于把数据附加在URL后，所以数据长度受URL长度所限，通常限制在2048个字符内
-  POST请求没有长度限制，理论上可以传输大量数据

3.安全性

- GET请求的数据是所有人可见的，会显示在URL中，所以不太安全，不适合传输敏感信息
- POST请求相对更安全，因为它不会显示在URL中，但是通过网络抓包工具还是能查看到

4.缓存

- GET请求能够被缓存，且能通过浏览器前进，后退访问，可以保存在浏览器历史记录中，能够被书签
- POST请求不能够被缓存，不会保留在历史记录中，也不能通过前进后退按钮访问，不能够被书签

5.幂等性

- GET请求是幂等的，多个相同的GET请求返回相同的结果，也就是多次访问不会改变资源的状态
- POST请求通常不是幂等的，它用于创建或更改资源，因此多次发送相同的POST请求可能每次都会有副作用

6.用途

- GET请求用来请求服务器发送资源，例如页面，图像，数据等
- POST请求用来提交表单数据，上传文件，或者通过API与服务器进行交互时创建资源和更新资源


##  2.POST和PUT请求的区别
1.用途

- POST请求常用于创建新的资源，当你不知道新的资源的URI想让服务器帮你创建一个时，使用POST。除了创建资源，它也可以用于出发操作或函数
- PUT请求通常用于更新已存在的资源，或者创建一个已知URI的新资源，如果你想替换目标资源的所有当前表示，用PUT

2.幂等性

- POST是非幂等的，意味着多次相同的POST请求，可能每次都会在服务器上生成新的资源
- PUT是幂等的，意味着多次执行相同的PUT请求，服务器上的资源情况不变

3.服务端的操作

- POST请求，它请求的结果通常是创建一个或多个新资源，返回时包含新资源的URI
- POST请求是将服务器上的目标资源与请求的内容进行替换

4.客户端提供的数据

- POST请求中，数据被视为新资源的一个整体，客户端不需要提前知道资源的URI，由服务端来创建
- PUT请求中，客户端指明了要创建或更新资源的URI。请求的数据体是对服务端URI的完整替代。

## 3.常见的HTTP请求头和响应头
HTTP请求头和响应头是HTTP消息的一部分，它们携带额外的信息（如客户端或服务器的信息、资源的元数据等）以帮助请求或响应

常见的HTTP请求头：

    1.Accept - 指定客户端能够接收的内容类型，如Accept:text/html
    2.Accept-Encoding - 指定客户端支持的内容编码类型，比如gzip或deflate
    3.Authorization - 包含凭证信息，通常用于服务器认证
    4.Cache-Control - 指示请求的缓存机制，比如Cache-Control: no-cache
    5.Content-Length - 请求消息体的长度
    6.Content-Type - 请求主体的MIME类型，例如Content-Type: application/json
    7.Cookie - 存放与服务器交互的cookie
    8.Host - 指定请求的服务器的域名和端口号
    9.User-Agent - 包含了有关客户端软件的信息，如浏览器类型和版本
    10.Referer - 表示发送请求的页面的地址
    11.Origin - 表明预期请求发起的源

常见的HTTP响应头

    1.Access-Control-Allow-Origin - 指定哪些网站可以参与跨域资源共享（CORS）
    2.Cache-Control - 指示响应的缓存机制
    3.Content-Encoding - 应用于响应主题的编码方式
    4.Content-Length - 响应消息体的长度
    5.Content-Type - 响应主题的MIME类型
    6.Set-Cookie - 告诉客户端保存一个cookie
    7.Date - 发送响应的日期和时间
    8.ETag - 资源的特定版本标识，用于比较和缓和
    9.Expires - 指定响应内容过期的时间
    10.Location - 用于重定向指向新的URL
    11.Server - 包含有关服务器软件的信息

##  4.常见的HTTP请求方法
- GET:请求指定的页面信息，并返回实体主体
- HEAD:和GET方法类似，但不会返回实体主体，只返回头信息
- POST:用于将客户端数据发送到服务器，比如表单提交
- PUT:从客户端向服务器传送的数据取代指定的文档的内容
- DELETE:请求服务器删除指定的页面
- PATCH:用于对已知资源进行局部更新
- OPTIONS:用于获取目的资源所支持的通信选项
- CONNECT:将连接改为管道方式的代理服务器
- TRACE:回显服务器收到的请求

##  5.常见的HTTP响应码

- 1xx(信息性状态码):接受的请求正在处理
- 2xx(成功状态码):请求正常处理完毕
  * 200 OK:请求成功
  * 201 Created:请求成功并且服务器创建了新的资源
  * 204 No Content: 请求成功但没有内容需要返回
- 3xx(重定向状态码):需要进一步的操作以完成请求
  * 301Moved Permanently:永久重定向
  * 302 Found:临时重定向
  * 304 Not Modified:资源未修改，可使用缓存的版本
- 4xx(请求错误状态码):请求含有语法错误或不能被执行
  * 400 Bad Request:服务器不理解请求的语法
  * 401 Unauthorized:请求需要用户的认证。
  * 403 Forbidden:服务器理解请求客户端的请求，但是拒绝执行此请求
  * 404 Not Found:服务器找不到请求的网页
- 5xx(服务器错误状态码):服务器处理请求出错
  * 500 Internal Server Error:服务器内部错误，无法完成请求。
  * 501 Not Implemented:服务器不支持请求的功能，无法完成请求。
  * 503 Service Unavailable:服务器暂时的无法处理请求(可能是过载或维护) 

##  6.OPTIONS请求方法及使用场景
OPTIONS方法是用于请求获得由Request-URI标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。

OPTIONS请求方法的主要用途有两个:
  - 获取服务器支持的所有HTTP请求方法；
  - 用来检查访问权限。例如：在进行CORS跨域资源共享时，对于复杂请求，就是用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。


##  7.HTTP1.0和HTTP1.1之间有哪些区别

1.连接重用
  - 在HTTP/1.0中，默认情况下，每个请求/响应对都要打开一个新的连接，并在响应后立即关闭。这意味着每个请求都会经历完整的连接建立、数据传输和连接断开的过程，导致额外的延迟
  - HTTP/1.1引入了持久连接(也称为连接重用或Keep-Alive)。默认情况下，连接在发送请求后保持打开状态，可以被后续的请求服用，除非明确要求关闭。这减少了连接和断开的开销，提高了网络的传输效率

2.管道化

  - HTTP/1.1新增了对请求的管道化处理。在同一个TCP连接中，客户端可以在等待第一个请求的回复时发送后续的请求。这可以进一步降低延迟
  - HTTP/1.0不支持管道化，每一个请求都需要等到前一个响应后才能发送

3.分块传输编码

  - HTTP/1.1支持分块传输编码，允许服务器在发送完整响应之前开始传输响应。这对于动态生成的内容非常游泳，因为服务器可以传输数据的同时继续处理剩余的数据
  - HTTP/1.0需要服务器在发送响应之前确定整个响应的内容长度

4.缓存控制

  - HTTP/1.1引入了更复杂的缓存控制机制，如ETag、If-Modified-Since、If-Unmodified-Since、If-Match、If-None-Match等头部字段用来更有效地控制对资源的缓存。
  - HTTP/1.0的缓存控制较为基本，主要使用Pragma和Expires头部字段

5.Host头部

  - HTTP/1.1引入了Host头部，允许多个域名(虚拟主机)在相同的IP地址和端口上共存。HTTP/1.1的请求被要求包含Host头部
  - 在HTTP/1.0中，因为没有Host头部，每个服务的IP地址/端口组合只能对应一个域名

6.请求方法和状态码

  - HTTP/1.1新定义的请求方法包括：
    * OPTIONS
    * PUT
    * DELETE
    * TRACE
    * CONNECT
  - 响应码略

7.对Keep-Alive的理解

  Keep-Alive是HTTP/1.1协议的一个机制，用于保持连接持续活动，允许在同一个TCP连接中发送和接收多个HTTP请求/响应，而不是每次请求/响应都重新建立连接

  在HTTP/1.0中，每完成一个请求/响应周期，连接默认就会关闭，这称为"非持久连接"。每次HTTP交互都需要进行新的TCP三次握手，这增加了延迟和网络负担。随着网络活动的增多，这个问题变得尤为突出。

  为了解决这个问题，HTTP/1.1引入了持久连接(也称为连接复用或Keep-Alive)，特点如下:

  - 减少延迟:避免了因为建立新的TCP连接而产生的延迟(TCP三次握手)
  - 减少资源消耗:复用连接减少了服务器和客户端维护大量连接的需要，从而节省了资源
  - 增加吞吐量:因为连接维持开启，更快的开始数据传输，整体网络吞吐量得到提升

Keep-Alive在HTTP头部使用的两个字段是Connection和Keep-Alive。Connection:Keep-Alive指示这个连接将保持活动状态;Keep-Alive头部可以包含额外的指令，如最长持续时间(timeout)和最大请求数(max),指示连接应保持打开状态的时间和连接上可以发送的最大请求数量。

最终，服务器和客户端可以协商决定是否使用Keep-Alive,以及它的行为。如果任一方决定关闭连接，它们可以发送Connection:close头部来结束连接。

需要注意的是，在现代HTTP实践中，虽然Keep-Alive特性大大提高了HTTP/1.1的性能，但它也引入了某些问题，如服务器端需要处理大量半开连接(half-open connections)导致的资源消耗。随着HTTP/2和HTTP/3的发展，更高效的连接管理策略被采用,例如HTTP/2的多路复用(multiplexing)允许在单个连接上几乎同使发送多个请求和响应

##  8.HTTP请求报文的是什么样的？
HTTP请求报文是由客户端发送给服务器以发起请求的信息。一个标准的HTTP请求报文由三个主要部分组成:请求行、请求头部(Headers)和请求体(Body,不是所有请求都有)

1.请求行:
  - 包括请求方法、请求的资源路径(URL或URI的一部分)和HTTP协议的版本。
  - 例如:GET /index.html HTTP/1.1

2.请求头部:
  - 包含了描述请求的Metadata，可以有很多行，每个头部详细描述了请求的信息、客户端信息等。
  - 例如：
  ```     Host: www.example.com
     User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
     Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
     Accept-Language: en-US,en;q=0.5
     Accept-Encoding: gzip, deflate
     Connection: keep-alive
     Cookie: sessionId=abc123
  ```
3.空行

  - 请求头部和请求体之间有一个空行，表示请求头部的结束

4.请求体(可选)

  - 不是所有的请求都有请求体，通常只有POST和PUT这类请求会包含请求体
  - 包含了发送给服务器的数据，通常是在POST请求中提交表单数据时使用

##  9.HTTP响应报文是什么样的？
HTTP响应报文是服务器在收到客户端的HTTP请求后，返回给客户端的信息。一个标准的HTTP响应报文由三个主要部分组成:状态行、响应头部(Headers)、响应体(Body,不是所有响应体都有)。

1.状态行
  - 包括HTTP协议的版本、状态码及其原因短语。
  - 例如:HTTP/1.1 200 OK

2.响应头部
  - 包含了描述响应的Metadata,可以有多个头部行,每个头部详细描述了服务器的信息、响应体的内容类型和长度、缓存控制等
  - 例如:
```
     Date: Wed, 21 Oct 2020 07:28:00 GMT
     Server: Apache/2.4.1 (Unix)
     Content-Type: text/html; charset=UTF-8
     Content-Length: 88
     Connection: close
```
3.空行
  - 响应头部和响应体之间有一个空行,表示响应头部的结束

4.响应体(可选):
  - 包含服务器对请求的回应数据;比如请求网页时,它会包含HTML内容。
  - 例如:网页的HTML,图片的二进制数据,或者是JSON/XML数据等

下面是一个HTTP响应报文的例子:
```
HTTP/1.1 200 OK
Date: Sun, 10 Oct 2020 14:28:00 GMT
Server: Apache/2.4.1 (Unix)
Last-Modified: Sat, 09 Oct 2020 14:28:00 GMT
Content-Type: text/html; charset=UTF-8
Content-Length: 88
Connection: close

<html>
<head>
  <title>An Example Page</title>
</head>
<body>
  Hello World, this is a very simple HTML document.
</body>
</html>
```

##  10.HTTP协议的优点和缺点
HTTP的优点包括:

1.简单易懂:HTTP的请求和响应模型简单明了,便于理解和使用,这使得它容易被广泛采用

2.灵活:HTTP允许传输任何类型的数据对象,只要服务端和客户端知道如何处理这些数据即可

3.无状态性:HTTP是无状态的协议,服务器不保存关于客户的任何数据。这种设计使得服务器更容易管理,因为不需要维护客户的连接状态,可以更好地服务于更多的客户

4.可扩展性:HTTP头部允许传递额外的信息,而且协议的标准允许自定义头部,为协议的扩展提供了便利

5.与网络基础设施兼容良好:HTTP在80端口工作,易于通过防火墙和代理,兼容性强

6.支持分布式环境:HTTP支持代理服务器和缓存服务器,可以减轻主服务器的负担,提高请求处理速度

HTTP的缺点包括:

1.不安全:HTTP本身不提供加密功能，数据以明文方式传输，因此容易被截获和篡改。虽然HTTPS(加密的HTTP)可以解决这个问题，但还是有很多网站在使用不安全的HTTP

2.无状态性也可能是缺点:虽然无状态设计使得服务器简单，但是它也限制了无法保持交互状态。例如，无法在不使用诸如Cookies或会话跟踪工具的情况下记住用户的信息

3.TCP连接的使用:每次HTTP请求都需要建立一个TCP连接(在HTTP/1.1中，这个问题可以通过持久连接进行一定程度的缓解)，这个过程可能导致相对较高的延迟，并且增加服务器端处理链接的复杂性

4.性能问题:HTTP/1.1虽然支持持久连接，但每个传输仍然需要一个完整的请求响应周期。HTTP/2通过引入流、多路复用等特性来提高性能，但是这些特性不是HTTP协议原始版本中的

5.数据冗余:HTTP的头部信息在每次请求时几乎都是重复的，特别是在一系列的请求中，这增加了不必要的数据传输量，特别是在移动网络较慢的情况下

##  11.当在浏览器中输入 Google.com 并且按下回车之后发生了什么？

1.域名解析

  - 浏览器首先检查缓存是否有"google.com"的IP地址(包括浏览器缓存、系统缓存、路由器缓存)。
  - 如果没有缓存，请求会发送到DNS服务器来解析域名"google.com"到对应的IP地址

2.建立TCP连接
  - 浏览器利用解析得到的IP地址，发起到Google服务器的TCP连接请求，这通常涉及到一个三次握手过程

3.发送HTTP请求
  - 一旦TCP连接建立，浏览器会构建HTTP请求并通过TCP连接发送给Google服务器
  - 请求包括一个请求行(通常是GET方法)，请求头部(如User-Agent,Accept-Language等)，以及必要的cookie数据

4.服务器处理请求并发送HTTP响应
  - Google的服务器接受请求后处理，然后返回一个HTTP响应。
  - 响应码通常包括状态码(如200 OK),HTTP头部信息，和请求的数据(即Google首页的HTML)

5.浏览器渲染页面
  - 浏览器接收到HTML响应后开始解析并构建DOM树
  - 浏览器处理HTML中的CSS和Javascript，并可能发出额外的HTTP请求去获取诸如图片、CSS文件、javascript文件等其他资源

6.关闭TCP连接
  - 页面加载完成后，TCP连接可以通过四次挥手过程关闭，也可能会根据HTTP头部信息中的Connection字段保持打开以供后续请求复用(Keep-Alive)

7.用户看到完全渲染的页面
  - 最终用户会在浏览器中看到完全渲染的Google首页


##  12.URL有哪些组成部分
URL(统一资源定位器)由若干个部分组成，用于指定互联网上资源的位置。一个典型的URL可能包含以下几个组成部分

1.协议(Scheme):
  - 指定了访问资源所使用的协议类型，例如http、https、ftp等
  - 例如:https://

2.子域名(Subdomain)
  - 通常是对网站的一个子集或者子分类
  - 例如:subdomain.example.com中的subdomain

3.域名(Domain)
  - 表示资源所在的服务器的名称，通常是该网站的可读名称
  - 例如: example.com中的example

4.顶级域名(TLD)
  - 域名的最后部分，表示域名所属的顶级域(如.com、.org、.net等)

5.端口(Port)(可选)
  - 用于访问资源的服务器端口号，如果省略，则使用协议的默认端口
  - 例如:80、443

6.路径(Path)
  - 表示资源在服务器上的具体位置。对应着文件系统中的路径，但也可能是抽象的，由服务器解释
  - 例如:/folder/page.html

7.查询字符串(Query)(可选)
  - 以问号(?)开头，后面跟着一个或多个参数。用于传递额外信息给服务端
  - 例如:?key1=value1&key2=value2

8.片段(Fragment)
  - 以井号(#)开头，指定网页中的一个片段或位置，常用于定位到页面的特定部分
  - 例如:#section1


##  13.HTTP1.1和HTTP2.0的区别
1.二进制协议
  - HTTP/1.1是一个文本协议，请求和响应中的头部信息都是文本形式
  - HTTP/2引入了二进制格式，使得解析更加高效，减少了错误，并且减少了不必要的网络开销

2.多路复用
  - 在HTTP/1.1中，每个请求需要一个TCP连接，这导致了连接数量的增加，并容易引起队头阻塞问题
  - HTTP/2通过使用单一的TCP连接进行多个请求和响应的多路复用，消除了队头阻塞，且更有效地使用网络资源

3.头部压缩
  - HTTP/1.1不包含头部压缩功能，导致头部携带的数据往往很大
  - HTTP/2使用HPACK压缩机制来减小头部大小，减少网络传输数据量

4.服务器推送
  - HTTP/1.1不支持服务器推送，服务器只能对客户端请求作出响应
  - HTTP/2允许服务器无需客户端请求即可发送资源，这样可以减少延迟，并充分利用连接的性能，提前发送客户端可能需要的资源

5.流优先级
  - HTTP/1.1不支持指定请求的优先级
  - HTTP/2支持为请求设置优先级，服务器可以根据优先级来决定先处理哪个请求，使得资源调度更加高效

6.安全性
  - 虽然HTTP/1.1支持HTTPS，但HTTP/2的规范建议使用TLS加密传输，以提高安全性
  - 许多浏览器实现HTTP/2时，实际上已经要求必须与TLS一起使用

##  14.HTTP2的头部压缩算法是怎样的？
HTTP/2使用称为HPACK的头部压缩算法来减少传输中头部数据的大小。HPACK压缩算法针对HTTP头部的特性进行了优化，并且通过以下几个主要的机制来减少需要传输的头部字节:

1.静态表
  - 用于保存常见的HTTP头部名称和值。这个表时预定义的，并且在客户端和服务器之间共享。它包含了一些最常用的HTTP头部字段，如:method,:path,:scheme,:status及常用值

2.动态表
  - 在连接期间，客户端和服务器可以通过HPACK将头部名称和值添加到动态表中，这样在后续的请求和响应中就可以通过索引来引用这些条目，而不是再次发送整个名称和值

3.霍夫曼编码
  - 核心数据使用霍夫曼编码进行压缩。霍夫曼编码是一种统计编码，它以常见的字符分配较短的编码，为不常见的字符分配较长的编码

4.索引表示
  - 当使用索引访问静态表或动态表中的头部表示时，只需要发送一个小的索引值

5.字面量表示
  - 如果头部不在静态表和动态表中，它可以以字面量形式发送，即使是字面量形式的头部也可以选择霍夫曼编码进行压缩

6.增量更新
  - 动态表中的头部可以通过请求进行增量更新，这意味着随着时间的推移，对头部进行的更改可以通过传输最小的增量进行


##  15.说一下HTTP 3.0
HTTP/3是互联网工程任务组(IETF)正在开发的HTTP协议的最新版本。它建立在先前版本的基础之上，并引入了一些关键的改进以进一步提升网络性能和可靠性。最显著的变化是HTTP/3不适用TCP作为传输层协议，而是使用QUIC(Quick UDP Internet Connections)

以下是HTTP/3的一些重要特征

1.基于QUIC协议
  - HTTP/3使用基于UDP的QUIC协议。QUIC解决了TCP在建立连接、传输可靠性、拥堵控制和多路复用方面的一些问题

2.减少连接延迟
  - QUIC通过减少握手过程(通常只需要单个往返时间)来显著减少连接的建立时间。这对于移动网络或需要启动多个连接进行资源获取的情况非常有益

3.连接迁移
  - QUIC具备连接迁移的特性，这意味着即使网络环境改变(例如切换Wi-Fi或移动网络)，连接状态也可以保持稳定，减少中断

4.独立流的拥堵控制
  - QUIC将不同的请求分散在独立的流上，并且每个流有自己的流控和拥堵控制。与HTTP/2不同的是，一个流的延迟不会影响其他流

5.内置加密
  - QUIC集成了TLS 1.3加密，保护用户数据，防止中间人攻击，并且加密的握手过程与QUIC的快速连接建立相结合

6.零RTT连接复用
  - 对雨之前已经建立过的连接，QUIC支持零往返时间(0-RTT)重启，这可以在重连时进一步减小延迟

##  16.HTTP和HTTPS协议的区别
HTTP和HTTPS的主要区别在于安全性方面。它们都用于在客户端与服务器之间传输数据，但使用不同的方式连接和传输数据。以下是HTTP和HTTPS的核心区别：

1.安全性
  - HTTP本身不包含任何加密机制，所以传输的信息(包括网址、传输的内容、用户凭据等)都是明文的，任何人在途中拦截流量都能直接读取这些信息。
  - HTTPS在HTTP的基础上增加了SSL/TLS(安全套接字层/传输层安全)加密，这个加密层可以保护传输过程中的数据不被第三方轻易截获和篡改

2.端口号
  - HTTP服务默认端口时80
  - HTTPS服务默认端口号时443

3.URL前缀
- HTTP网站的URL以http://开头
- HTTPS网站的URL以https://开头

4.证书要求
  - HTTP不需要证书
  - HTTPS需要SSL/TLS证书来验证服务器的身份，并用于加密数据。这些证书需要由信任的证书颁发机构(CA)颁发

5.性能
  - 由于数据加密和解密过程中需要消耗一定的计算资源，HTTPS在性能上可能比HTTP慢一些

# 二、HTTPS

##  1.什么是HTTPS协议？
HTTPS是HTTP协议的安全版本。HTTP协议(超文本传输协议)是用于从服务器传输超文本到本地浏览器的传递协议，但它不加密，意味着第三方可能窃听、篡改或伪造请求

**HTTPS协议的基本概念**：

1. **安全性**：HTTPS使用SSL或TLS(传输层安全协议)在客户端和服务器之间建立加密链接，确保传输的数据在网络中为加密形态，从而提供数据传输的安全性
2. **加密**：它通过加密传输的数据来保护通信免受监听和中间人攻击，这意味着用户与网站之间交换的数据无法被未授权者阅读
3. **完整性**：确保数据在传输过程中不被篡改
4. **认证**：通过证书验证服务端的身份，避免用户流量被重定向到恶意站点。

**如何工作**：

HTTPS在HTTP上叠加了一层SSL/TLS加密层工作流程如下：

1. **建立连接**：当用户尝试通过HTTPS访问网站时，服务器会将其SSL/TLS证书发送给用户的浏览器
2. **验证证书**：浏览器将检查该证书的有效性，包括该证书是否受信任的证书颁发机构签发，是否有效，以及该证书的域名是否和请求的域名相匹配
3. **密钥交换**：一旦证书验证成功，浏览器和服务器之间回建立一个加密的会话，这涉及到一个密钥交换过程来建立一个对称加密
4. **加密通信**：密钥交换完成后，浏览器与服务器之间的所有通信都将通过这个密钥加密和解密，确保传输的数据安全


##  2.TLS/SSL的工作原理

TLS(传输层安全)和SSL(安全套接字层)是确保网络通信安全的协议，TLS是SSL的后续版本，它们通过以下步骤协同工作来保护数据安全：

1. **客户端发起连接**：客户端(如web浏览器)通过HTTPS请求与服务器建立安全连接
2. **服务器响应**：服务器接收到客户端请求后，将它的SSL/TLS证书发送给客户端。证书包含服务器的公钥以及证书颁发机构(CA)的签名
3. **客户端验证证书**：客户端验证服务器证书的合法性。包括证书是否未过期、域名是否一致、证书是否由可信任的CA签发
4. **密钥交换**：
- **适用TLS1.2及之前的版本**：
  - 客户端使用服务器证书中的公钥加密一个随机生成的对称加密密钥(会话密钥)，然后将加密后的密钥发给服务器
  - 服务器使用自己的私钥解密会得到会话密钥
- **使用TLS1.3的版本**：
  - 它使用零知识证明和一系列密钥衍生步骤来建立共享的密钥，而不是发送一个加密的密钥

5. **安全的会话**：现在服务器和客户端都拥有同一个会话密钥，他们就用它进行对称加密，可以开始安全地交换信息了
6. **加密数据传输**：利用会话密钥，双方交换的所有信息都会被加密后发送，并在接收端被解密。这确保了传输过程中的数据的机密性和完整性

**TLS/SSL握手详解**

业界已经普遍采用了TLS协议，而SSL已经不再推荐使用。在TLS握手过程中，包含了以下重要的步骤：

- **CilentHello**:客户端发送一个消息，指出它支持的TLS版本，加密套件列表(Encryption Suites)，以及其他一些会话设置
- **ServerHello**：服务器选择客户端提供的选项列表中的一个，并通知客户端该会话将使用的选项
- **Certificates & Key Exchange**:服务器发送证书并可能包含一些密钥交换数据。客户端可能也会发送密钥交换数据
- **Secure Key Determination**:客户端和服务端利用交换的密钥信息来生成对称密钥，通常是使用Diffie-Hellman密钥交换算法或类似方法，确保双方都能得到相同的密钥
- **Finished**：双方交换已完成的消息，这标志着握手的结束并验证了会话的开始

TLS协议的这些步骤提供了一种安全的方式来验证身份，建立加密的会话，并对数据进行加密， 从而确保了数据的机密性和完整性


##  3.数字证书是什么？
数字证书是一种用于确认持有者身份的电子文件，通常在网络交易和通讯中用于增加安全性。数字证书基于公钥加密的原理，由认证机构(CA)颁发，用以证明公钥的所有权以及证书持有人的身份信息

**数字证书包含的关键信息**：

- **公钥**：证书所有者的公钥，用于加密向其发送的消息或验证其签名的消息
- **持有者信息**：证书持有者的身份信息，如个人、公司或组织名称
- **颁发机构**：颁发和签发证书的证书颁发机构(CA)信息。
- **有效期**：证书的有效期限，证书过期后将不可信任
- **证书序列号**：证书的唯一序列号，用于识别证书
- **数字签名**：证书颁发机构的数字签名，证明证书的真实性

**数字证书的原理和作用**：

当服务器向客户端展示其数字证书时，客户端软件(如Web浏览器)会自动检查证书的有效性。这包括证书是否由客户端信任的CA签发，是否未过期，以及是否被吊销

数字证书支撑了HTTPS协议，确保了通信双方能够确认对方的身份，防止了中间人攻击。通过数字证书提供的公钥，客户端可以与服务器安全地建立加密通道，并确保信息在传输过程中的安全

**数字证书的适用场景**：

- **HTTPS**:在Web服务器与客户端浏览器之间建立安全通信时使用SSL/TLS证书
- **电子邮件**：确保邮件内容的来源真实性和内容完整性
- **代码签名**：证明软件发布者的身份，并确保代码自发布以来未被修改
- **VPN**：在远程工作时，用于建立安全的网络连接

数字证书的核心价值在于它提供了一种安全的身份验证方式，增强了数据通讯和电子交易的信任度和完整性

##  4.HTTPS通信（握手）过程
HTTPS通信过程涉及一个握手阶段，该阶段建立了加密的通信通道，并验证了服务器的身份。以下是一个简化的握手过程

1. **客户端Hello(ClientHello)**

客户端发起通信，通常是当用户尝试建立HTTPS连接时。客户端Hello消息包括：

 - 支持的TLS版本
 - 支持的加密套件(如RSA, AES等)
 - 一个客户端生成的随机数(Client Random)，用于后续的密钥生成

2. **服务端Hello(ServerHello)**

服务器收到客户端的Hello消息后，会选择一个双方都支持的加密方法，并发送给客户端：
 - 选择使用的TLS版本
 - 选择使用的加密套件
 - 一个服务器生成的随机数(Server Random)

3. **服务器证书和密钥交换**

服务器将自己的数字证书发送给客户端。数字证书中包含了服务器的公钥。同使，服务器也可能发送一些必要的密钥交换信息

4. **客户端验证证书**

客户端验证服务器提供的证书是否有效，检测给出的证书受否是由受信任的CA颁发，证书是否未过期或已吊销，以及证书的公钥是否匹配域名

5. **密钥交换**

客户端使用证书中的公钥加密一个预主密钥(Pre-Master Secret)并发送给服务器。然后，客户端和服务器都是用Client Random, Server Random以及Pre-Master Secret通过一个固定的算法生成相同的会话密钥

对于TLS1.3版本，密钥交换过程使用Diffie-Hellman算法，不再需要直接传输预主密钥，增强了过程的安全性

6. **终结握手并验证**

客户端发送一个消息通知服务器将在随后的通信中使用会话密钥进行加密。此消息同时会包含之前所有通信内容的摘要，以供服务器验证。

服务器会送一个类似的消息给客户端，客户端验证摘要无误后，握手阶段结束

7. **加密通信**

握手成功之后，客户端和服务器使用会话密钥来加密他们之间的通信，保证数据隐私和完整性

这个过程确保了客户端与服务器之间数据传输的安全性和可靠性，同时也保护了用户的隐私。握手阶段为双方提供了通信所需的共享会话密钥，而不会暴露密钥信息给窃听者

##  5.HTTPS的优缺点
HTTPS协议，在提高网络传输安全性方面是非常关键的，它在HTTP的基础上通过SSL/TLS进行加密通信。以下是HTTPS的一些主要优缺点：

**HTTPS的优点**：

1. **加密**：HTTPS加密传输的数据，防止数据被窃听。即使数据被截获，也无法轻易被解析
2. **数据完整性**：HTTPS能够验证数据在传输过程中没有被修改，确保数据的完整性
3. **认证**：HTTPS提供了身份验证，确保客户端与服务器通信的真实性，防止中间人攻击(MITM)
4. **SEO改进**：搜索引擎(如Google)倾向于对HTTPS站点进行更好地排名，从而有助于搜索引擎优化(SEO)
5. **信任和信誉**：对于用户来说，浏览器中的锁标志以及HTTPS前缀增强了对网站的信任
6. **满足法规要求**：某些法规要求对敏感数据进行加密传输，比如支付卡行业数据安全标准(PCI DSS)

**HTTPS的缺点**

1. **性能开销**：加密和解密数据需要额外的服务器资源，可能会导致页面加载时间稍微增加
2. **证书成本**：虽然有的机构如Let's Encrypt提供免费证书，但某些证书(尤其是高级证书，例如EV SSL)可能很昂贵
3. **配置和管理**：安装和配置SSL/TLS证书，以及管理续期、撤销等可能比较复杂
4. **兼容性问题**：某些老旧的设备或浏览器可能不支持SSL/TLS协议，导致网站不可访问
5. **中间件和缓存问题**：由于HTTPS加密了数据，一些针对HTTP设计的基础架构、中间件、CDN和缓存策略可能需要调整以支持HTTPS


##  6.HTTPS是如何保证安全的？
HTTPS通过以下几个关键技术来保证数据传输的安全：

1. **加密**：客户端与服务器之间交换的数据都通过加密算法加密，这可以防止中间人能够窃听交流内容。即便数据被拦截，由于它是加密过的，未经授权的第三方也无法理解数据的真实内容
2. **身份验证**：HTTPS使用SSL/TLS证书提供身份验证，该证书由第三方信任机构(CA)签发。当用户访问一个HTTPS网站时，浏览器会验证服务器的SSL/TLS证书，确保用户与真正的服务器进行通信，而不是一个伪装的网站。这减少了钓鱼攻击和中间人攻击的风险
3. **完整性**：加密过程还包括完整性检查，确保在数据传输过程中未被篡改。这是通过使用消息摘要或散列算法实现的，任何对数据的修改都会导致计算出的散列值不匹配，从而检测到篡改
4. **安全握手**：在HTTPS通信开始时，客户端和服务器之间进行一个安全握手过程，这涵盖了证书验证、密钥交换等过程。握手协商出一个会话密钥，该密钥用于当前连接期间加密所有传输的数据
5. **密钥交换**：使用安全的密钥交换算法(如Diffie-Hellman)，即便交换数据过程被窃听，也无法得知最终协商的密钥，因为它们基于一种只有参与方才能计算出共享密钥的数学难题
6. **安全协议**：SSL/TLS协议本身经过多年的发展，采用等多种加密技术与算法，保证只有对等方才能解密通信内容。此协议不断更新，淘汰了不安全的就算发，保持与现代密码学的同步


# 三、DNS协议介绍

##  1.DNS协议是什么
1. **概念**：DNS是域名系统(Domain Name System)的缩写，提供的是一种主机名到IP地址的转换服务，就是我们常说的域名系统。它是一个由分层的DNS服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP数串

2. **作用**：将域名解析为IP地址，客户端向DNS服务器(DNS服务器有自己的IP地址)发送域名查询请求，DNS服务器告知客户机Web服务器的IP地址


##  2.DNS同时使用TCP和UDP协议？

一般情况下，DNS查询主要使用UDP协议：

**UDP**：传统的DNS查询使用UDP协议，因为它更快。UDP是无连接的，执行简单的请求-响应模型，这使得DNS查询可以快速执行。由于大多数DNS响应数据包都非常小(典型的限制是512字节)，它们适合单个UDP数据包发送

但在某些情况下，DNS查询会使用TCP协议：

**TCP**:DNS通过TCP协议进行通信的情况包括但不限于：
- 当DNS响应数据超过UDP包的大小限制时(512字节，或者通过EDNS扩展后的4096字节)，就需要使用TCP了。TCP没有这样的数据包大小限制
- 在域传送(zone transfer)中，如AXFR和IXFR请求，通常使用TCP，因为这些请求通常涉及大量数据
- 如果DNS查询或响应在UDP中出现丢包情况，可能会尝试使用TCP重传

总的来说，DNS使用UDP来提供快速、效率高的查找服务，并在需要的情况下依赖TCP来确保数据的完整性和安全性。当今的DNS服务器和客户端都支持在UDP和TCP端口53上进行通信

##  3.DNS完整的查询过程

DNS服务器解析域名的过程：

1. 首先会在**浏览器的缓存**中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步
2. 将请求发送给**本地DNS服务器**，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
3. 本地DNS服务器向**根域名服务器**发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
4. 本地DNS服务器向**顶级域名服务器**发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
5. 本地DNS服务器向**权威域名服务器**发送请求，域名服务器返回对应的结果
6. 本地DNS服务器将返回结果保存在缓存中，便于下次使用
7. 本地DNS服务器将返回结果给浏览器

比如要查询www.baidu.com的IP地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的DNS服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责.com的顶级域名服务器的IP地址的列表。然后本地DNS服务器再向其中一个负责.com的顶级域名服务器发送一个请求，负责.com的顶级域名服务器返回负责.baidu的权威域名服务器的IP地址列表。然后本地DNS服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的IP地址列表


##  4.迭代查询与递归查询

DNS查询主要有两种模式：迭代查询和递归查询。两者之间的主要区别在于查询解析过程的不同

**递归查询**：

当一个客户端(例如计算机或者路由器)向DNS服务器发送一个递归查询请求时，这个服务器会负责处理整个查询过程，从根服务器开始一直到获得解析结果，中间过程对客户端是透明的。如果这个DNS服务器不具备请求的记录信息，它会作为客户端去请求上一级服务器，并将结果返回给原始请求者

**迭代查询**：

当一个DNS服务器接收到客户端的请求时，如果这个请求是一个迭代查询，服务器会提供最直接的答案。如果这个DNS服务器不具备解析的完成信息，它并不会去请求其他服务器，而是会告诉客户端下一个能够向其提供信息的服务器的地址。然后客户端会向这个新的服务器发起新的查询，这个过程会重复进行，直到得到最终结果


**示例对比**：

假设我们正在查找"www.baidu.com"的IP地址

1. **递归查询**：
   - 客户端向本地DNS发送一个递归查询请求
   - 本地DNS向跟服务器发送查询请求
   - 根服务器将对应域的顶级域(TLD)服务器地址返回给本地DNS
   - 本地DNS向TLD服务器发送查询请求
   - TLD服务器将对应域的权威名称服务器地址返回给本地DNS
   - 本地DNS向权威名称服务器发送查询请求
   - 权威名称服务器将"www.baidu.com"的IP地址返回给本地DNS
   - 本地DNS最后将这个IP地址返回给客户端

2. **迭代查询**:
  - 客户端向本地DNS发起一个迭代查询请求
  - 本地DNS向根服务器发送查询，根服务器返回TLD服务器地址
  - 客户端接着向TLD服务器发送查询，TLD服务器返回权威名称服务器地址
  - 客户端最后向权威服务器发送查询，权威名称服务器返回"www.baidu.com"的IP地址

##  5.迭代查询和递归查询的主要区别？

1. **请求者的角色**:
   - 在递归查询中，客户端请求DNS服务器解析域名，然后DNS服务器负责代为完成整个解析过程，最终将结果返回给客户端。客户端只需等待最终结果
   - 在迭代查询中，客户端向DNS服务器请求域名解析，如果DNS服务器中没有缓存结果，它会指示客户端下一步应该查询的服务器。客户端将继续向推荐的服务器发起请求，直到获得最终解析结果
2. **查询过程**
   - 递归查询通常由服务端向本地DNS服务器发起，本地DNS服务器要么直接回复(如果有缓存结果)，要么递归地从其他DNS服务器擦汗寻，直到得到答案
   - 迭代查询通常发生在DNS服务器之间，一个DNS服务器如根服务器、顶级域名(TLD)服务器或权威服务器会告诉请求服务器下一个应该查询的服务器，直到找到精确信息
3. **查询责任**
   - 在递归查询中，单个请求的DNS服务器负责整个域名解析过程
   - 在迭代查询中，最终的域名解析责任在客户端手中，DNS服务器只是逐步指导客户端应该到哪里去找信息
4. **执行效率**
   - 递归查询可能更消耗资源，因为DNS服务器要完成整个解析过程，可能需要多次查询其他服务器
   - 迭代查询有效地将查询责任分散到多个DNS服务器上，每个服务器处理请求并指向下一个服务器，消耗较少资源
5. **使用场合**
   - 递归查询通常在用户的设备上开始，例如你的个人电脑或手机发起的查询，因为用户期望DNS服务提供完整的解析结果
   - 迭代查询更常见于DNS服务器间的查询，这些服务器具备完成查询的知识和能力


##  6.DNS记录和报文

DNS服务器中以资源记录的形式存储信息，每一个DNS响应报文一般包含多条资源记录。一条资源记录的具体的格式为：（Name，Value，Type，TTL）

其中TTL是资源记录的生存时间，它定义了资源记录能够被其他的DNS服务器缓存多长时间。

常用的一共有四种Type的值，分别是A、NS、CNAME和MX，不同Type的值，对应资源记录代表的意义不同

- 如果Type = A，则Name是主机名，Value是主机名对应的IP地址。因此一条记录为A的资源记录提供了标准的主机名到IP地址的映射
- 如果Type = NS，则Name是个域名，Value是负责该域名的DNS服务器的主机名。这个记录主要用于DNS链式查询时，返回下一级需要查询的DNS服务器的信息
- 如果Type = CNAME，则Name为别名，Value为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名对应的规范主机名，从而告诉查询主机区查询这个主机名的IP地址。主机别名主要是为了通过给一些复杂的主机名提供一个便于记忆的简单的别名
- 如果Type = MX，则Name为一个邮件服务器的别名，Value为邮件服务器的规范主机名。它的作用和CNAME是一样的，都是为了解决规范主机名不利于记忆的缺点


#  四、网络模型

## 1. OSI七层模型
ISO为了更好的使网络应用更为普及，推出了OSI参考模型

1. **应用层**

OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络协议有：HTTP，HTTPS，FTP，POP3、SMTP等

- 在客户端与服务器中经常会有数据的请求，这个时候就是会用到http(超文本传输协议)或https，在后端设计数据接口时，我们常常使用到这个协议
- FTP是文件传输协议
- SMTP是simple mail transfer protocol(简单邮件传输协议)，在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议


2. **表示层**

表示层提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一

在项目开发中，为了方便数据传输，可以使用base64对数据进行编解码。如果按功能来划分，base64应该是工作在表示层


3. **会话层**

会话层就是负责简历、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成

4. **传输层**

传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP，UDP就是在这一侧呢个。端口号即这里的"端"

5. **网络层**

本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是常说的IP层。这一层就是我们经常说的IP协议层。IP协议使Internet的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式

6. **数据链路层**

将比特组合成字节，再将字节组合成帧，使用链路层地址(以太网使用MAC地址)来访问介质，并进行差错检测。网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能


7. **物理层**

实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备由(各种物理设备)集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质

**OSI七层模型通信特点：对等通信**，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信


##  2.TCP/IP五层协议

1. **应用层**：直接为应用程序提供服务。应用层协议定义的使应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如HTTP协议(万维网服务)、FTP协议(文件传输)、SMTP协议(电子邮件)、DNS(域名查询)等
2. **传输层**：
   - **TCP(传输控制协议**)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段(segment)
   - **UDP(用户数据报协议)**：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报

3. **网络层**：负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机
4. **数据链路层**：负责将网络层交下来的IP数据包封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息(如同步信息、地址信息、差错控制等)
5. **物理层**：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境


# 五、TCP与UDP

##  1.TCP和UDP的概念及特点

TCP和UDP都是传输层协议，它们都属于TCP/IP协议族

**TCP-(传输控制协议)**

TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。它的主要特点和功能包括
- **面向连接**：在数据传输前，TCP需要建立连接。这个过程通常称为三次握手
- **数据传输可靠性**：TCP提供了确认机制、重传控制和数据校验，确保数据包无错误、不丢失、不重复，并且按序到达
- **流量控制**：TCP使用滑动窗口机制来避免发送方的数据溢出接收方的缓冲区
- **拥塞控制**：TCP能够感知网络中的拥塞，并能够通过减少数据的发送量来减轻其影响
- **有序数据传输**：TCP确保数据包的顺序性，使接收方能按发送顺序处理数据

TCP适用于要求数据准确无误传输的应用，如网页浏览、文件传输、邮件发送等

**UDP-(用户数据报协议)**

UDP是一种无连接的、不可靠的、基于数据报文的传输层协议。它的主要特点和功能包括：

- **无连接**：UDP在发送数据之前不需要建立连接，减少了建立和释放连接的开销
- **不保证可靠性**：UDP不提供数据包的确认机制，也不保证数据包的顺序或完整性。如果有错误，UDP也没有重传机制
- **简单的报头结构**：UDP的报头只有8个字节，比TCP的20个字节要少很多，这使得UDP的开销更小
- **支持广播和多播**：UDP允许发送广播信息和多播信息

UDP适用于对实时性要求高、可以容许一定丢包的应用，如在线视频和音频流、实时游戏、DNS查询等

**总结**
- TCP使面向连接、可靠的协议，适合传输重要数据，但相比UDP效率低下
- UDP使无连接、不可靠的协议，传输效率高，适合实时通信，但不保证数据的完整性和顺序
- 选择使用TCP还是UDP取决于应用场景和对数据传输质量的要求

##  2.UDP协议为什么不可靠？
UDP(User Datagram Protocol)协议被认为是不可靠的，主要是因为它缺少TCP(Transmission Control Protocol)协议所提供的几个关键特性，这些特性能够确保数据的安全、准确到达。UDP的设计使其简单、快速，但牺牲了可靠性。以下是UDP不可靠性的几个方面

1. **无连接**：UDP是一种无连接协议，这意味着发送数据之前不需要建立连接。因此，发送方不会持续追踪接收方的状态，如果网络状态不佳，数据可能会丢失
2. **没有确认机制**：UDP发送数据后，不会等待或期望接收到确认相应。发送方不会知道数据是否成功到达接收方
3. **不保证顺序**：UDP发送的数据报(datagrams)可能会以任意顺序到达接收方。UDP本身没有内置排序机制来重新排列乱序数据
4. **无重传机制**：如果数据在传输中丢失或遇到错误，UDP并不会重新发送这些数据。对于TCP来说，它会自动重试直至数据被确认接收
5. **没有流量控制和拥塞控制**：UDP不会根据网络条件调整发送速率。这可能会导致发送方过载接收方的能力或网络的带宽，引发网络拥塞
6. **简单的错误处理**：虽然UDP提供了数据校验和的机制，可以检测数据报在传输过程中是否损坏，但如果检测到错误，它不会进行修正，只能丢弃损坏的数据报

由于这些限制，UDP通常用于那些对实时性要求高、可以容忍丢包或错误的场景，例如在线视频流、VoIP(Voice over Internet Protocol)、实时游戏等。在这些应用中，用户通常倾向于忽略少量的数据丢失，也不愿意为了数据的完整性而承受额外的等待时间


##  3.TCP的拥塞控制机制

TCP的拥塞控制机制是一套算法，用来适应网络中的各种负载条件，防止过量的数据注入到网络中，从而避免网络拥塞。当网络拥塞发生时，数据包可能会丢失，导致传输效率降低。为了管理和避免这种情况，TCP使用了以下几种拥塞控制算法：

1. **慢启动(Slow Start)**：
   - TCP连接初始化时，拥塞窗口(cwnd)从一个很小的值(通常是1个MSS，即最大报文段长度)开始增长，每经过一个往返时延(RTT)拥塞窗口加倍，指数级增长，以快速寻找网络的承载能力
   - 如果发生数据包丢失(通过超时检测到)，慢启动阈值(ssthresh)设置为当时拥塞窗口的一半，拥塞窗口重置为一个MSS，重新开始慢启动过程
2. **拥塞避免(Congestion Avoidance)**：
   - 当拥塞窗口增长到ssthresh值时，拥塞控制算法从慢启动过渡到拥塞避免阶段
   - 在这个阶段，每经过一个RTT，拥塞窗口线性增长(每个RTT增长1个MSS)，为网络提供了稳定的带宽增长
3. **快速重传(Fast Retransmit)**：
   - 当发送方收到三个重复的ACK(表示有一个包未按顺序到达)时，它立即重传丢失的分组，而不用等待重传计时器的超市
4. **快速恢复**
   - 在快速重传之后，TCP执行快速恢复算法
   - 快速恢复算法用来避免慢启动。在收到三个重复ACK后，ssthresh设置为当时拥塞窗口的一半，拥塞窗口设置为ssthresh加上冗余的ACK数量，然后进入拥塞避免阶段

这些算法能够帮助TCP估计合适的数据发送率，以匹配当前网络的拥塞水平：在网络状态良好时增加发送速率，在检测到拥塞迹象时减少发送速率。随着网络技术的发展，除了以上标准的TCP拥塞控制算法外，也发展出了更多的算法，如CUBIC、BBR(Bottleneck Bandwidth and Round-trip propagation time)等，以适应不同网络环境和提升性能


## 4.TCP的流量控制机制
TCP的流量控制是一种机制，它确保发送者不会发送太多数据来淹没接收者。主要通过以下几种方式来实现：

**滑动窗口机制(Sliding Window)**

TCP使用滑动窗口协议作为其主要的流量控制机制。每个TCP段(segment)都带有顺序号(Sequence Number)和确认号(Acknowledgement Number)，这些是窗口机制的基石

- **发送窗口**：发送方维护一个发送窗口，该窗口规定了可以发送但尚未收到确认的数据流。窗口的大小(窗口限制)由接收方的接收窗口和当前的网络拥塞窗口的较小值来决定
- **接收窗口**：接收方告诉发送方它的接收窗口大小(Window field in TCP header)，即它们的缓冲区还能接收多少字节的数据，这样发送方就可以控制其发送的速率，不会超过接收方的处理能力

窗口大小可以动态调整，这就是滑动窗口的概念。当确认数据包到达发送方后，窗口会向前滑动，允许发送更多的数据

**流量控制算法**

除了基本的滑动窗口机制外，TCP还采用其他流量控制算法：

- **Zero Window Probe**:如果接收方的窗口大小变为，发送方会停止发送数据并定期发送零窗口探针(Zero Window Probe)来检查窗口是否重新打开
- **Window Update**：当接收方处理掉了一些数据并且有了更多的缓冲空间时，它会发送一个带有新窗口大小的ACK来更新发送方的发送窗口
- **Silly window syndrome prevention**:为了防止由于发送方频繁发送小量数据而导致的网络效率低下，TCP实现了算法来避免这种被称为"愚蠢窗口综合征"的问题

**流量控制的作用**

流量控制的主要目的是为了匹配发送方的发送速率与接收方的处理速率，从而：
- 避免发送方数据太快导致接收方的缓冲区溢出(防止数据丢失)
- 提高效率，保证网络资源的合理分配，使得通信双方都能稳定地发送和接收数据

流量控制由TCP的窗口机制自动处理，对于TCP的使用者来说是完全透明的。正因为TCP协议提供了这种内置的流量控制和拥塞控制机制，他被认为是一种可靠的传输协议，适合在不同的网络条件下传输重要数据


##  5.TCP的三次握手和四次挥手
TCP的三次握手和四次挥手是TCP协议建立和终止连接的过程。它们都是为了确保数据包的可靠传输

**三次握手-建立连接**

三次握手的步骤包括：

1. **SYN**:客户端向服务器发送一个SYN(同步序列编号)标志的数据包以建立连接，并指定客户端的初始序列号
2. **SYN-ACK**：服务器收到客户端的SYN请求后，需要确认客户端的SYN(发送ACK标志的数据包)，同时自己也发送一个SYN请求，该数据包包含服务器的初始序列号
3. **ACK**：客户端收到服务器的SYN-ACK后，会发送一个确认包(ACK)，完成三次握手，此时连接建立

这个过程确保了双方都知道彼此以及彼此的序列号是合法的，并准备好进行数据传输

**四次挥手-断开连接**

四次挥手的步骤包括：

1. **FIN**:当连接中的一方完成了数据发送任务，就发送一个FIN(结束)标志的数据包来关闭连接
2. **ACK**:另一方接收到FIN后，发送一个ACK包作为应答
3. **FIN**：之后，第二次FIN包被发送，通常是在处理完数据后，用来关闭另一方向这一方的数据传输
4. **ACK**:最后一步是确认第二个FIN包。在接收到这个确认后，双方都可以安全地关闭连接

在四次挥手过程中，待发送方收到来自接收方的最后一个ACK包之后，会进入一个TIME_WAIT状态。在这个状态下，会等待足够的时间确保对方接收到ACK包

**重要性**

这两个过程都是TCP健壮性的一部分，它们确保了在一个不可靠的网络上可以可靠地建立和结束连接。三次握手和四次挥手通过逐步建立和断开连接，提供了一种防止旧的重复数据包干扰新连接的方法，并确保数据传输的双向性结束时数据完整性


##  6.TCP粘包是怎么回事，如何处理？

TCP粘包(或TCP拆分)是TCP协议中的一个现象，在这个现象中，多个发送的消息被合并到一个TCP段中传输，或者一个发送的信息被拆分成多个段进行传输。这通常发生在发送数据的应用程序和网络效率优化之间的一个交互点上

**为什么会发生TCP粘包？**

主要由以下几个原因导致：

1. **TCP是基于字节流的**：作为一种流协议，TCP并不保留信息的边界，而是以一序列的无边界字节方式发送数据
2. **发送缓冲区(Nagle算法)**：为了减少网络上的小包数目，提高效率，TCP使用Nagle算法将小的数据包组合到一起发送
3. **接收缓冲区**：接收端会根据自己的缓冲区大小和处理能力，决定何时从缓冲区中读取数据，这可能导致同时读取了多个数据包
4. **MSS(最大报文段长)**：TCP为了防止报文段过大而被网络中的其他设备拆分，会通过MTU(最大传输单元)来确定一个合理的MSS值，保证每个TCP段都能顺利传输。这可能导致大消息被拆分多次发送


**处理TCP粘包问题的策略**

1. **应用层协议**:设计应用层协议，确保接收方能够正确地分辨消息的界限。常用的方法包括：
   - 在每个消息的开始处加上固定长度的header，通常包含消息的长度信息
   - 使用特殊的序列作为消息的分隔符

2. **定长消息**：发送固定长度的报文。如果应用程序层面可以保证所有的消息都是一个长度，那么粘包问题就可以用固定大小的缓冲区来读取
3. **结束字符**：使用特殊字符或字符串来标记一个消息的结束，如HTTP协议中以\r\n\r\n来标记请求头的结束
4. **关闭Nagle算法**：程序可以关闭TCP套接字的Nagle算法，这样可以减少发送端的延迟和可能的粘包问题，但可能会增加网络的负载
5. **应用层协议解析**：应用程序可以采用定制的协议解析逻辑，根据预定义的格式(如JSON、XML等)处理数据，确保消息边界。

**解决策略的选择**

为了有效处理粘包问题，选择哪种策略主要取决于具体的应用场景和要求。一般来说，构建一个健壮的应用层协议是一种常见的作法。通过在应用层处理消息边界，你可以轻松应对TCP的这一特性

# 六、WebSocket

##  1.对WebSocket的理解

WebSocket是一种网络通信协议，它提供了在单个长期连接上进行全双工、双向通信的能力。WebSocket设计用于Web浏览器和服务器之间，但也可用于任何客户端与服务器之间的通信。以下是对WebSocket的一些基本理解和特点：

**基本理解**
- **全双工通信**：WebSocket允许服务器和客户端之间进行双向实时数据传输。这意味着客户端和服务器可以同时发送数据，不需要像HTTP请求那样的请求/相应模式
- **持久连接**：一旦WebSocket连接建立，则保持开放状态，允许持续的数据传输，指导任何一方显示地关闭连接
- **低延迟**：WebSocket旨在减少通信过程中的开销和延迟。相比于每次通信都需要建立的HTTP协议，WebSocket只需要一次握手，便能实现持久连接和低延迟通信
- **兼容HTTP**：WebSocket在握手阶段与HTTP协议兼容。WebSocket的建立是通过HTTP请求进行的，但是协议是不同的

**连接过程**
- **握手**：使用HTTP协议发起WebSocket连接时，客户端会发送一个包含"Upgrade:websocket"头部的HTTP请求，来告诉服务器它希望建立一个WebSocket连接
- **协议升级**：如果服务器支持WebSocket，它会以状态码101 Switching Protocols相应，并升级协议从HTTP到WebSocket

**特点**
- **消息驱动**：WebSocket通信基于消息，而非字节流，这有助于标记和处理构成完成通信的独立单元
- **资源需求少**：相比于HTTP轮询，WebSocket需要的服务端资源更少，因为它消除了多次建立和重新建立连接的需要
- **二进制或文本数据**：WebSocket协议支持传输文本数据(如JSON)或二进制数据(如ArrayBuffer)，这为开发者提供了灵活性


**应用场景**

WebSocket广泛应用于需要实时数据传输的场景

- **在线游戏**：为了快速通信和数据同步
- **聊天应用**：提供即时的消息传输
- **实时通知**：如股票市场更新、体育赛事直播
- **协同编辑**：允许多个用户实时编辑同一文档

WebSocket可以解决传统HTTP协议在实时通信方面的一些缺点，为互联网应用带来更接近于桌面应用的互动体验


##  2.即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别

即时通讯通常要求客户端和服务器之间能够实时或近乎实时地交换消息。在实现即时通讯方案时，有多种技术可以使用，包括短轮询、长轮询、服务器发送时间(SSE)和WebSocket。以下是这些技术之间的区别

**短轮询(Short Polling)**

短轮询是最简单的实时通讯方式。客户端通过定期发送HTTP请求到服务器来检查是否有新的信息。服务器立即处理每个请求，如果有新数据就发送给客户端，否则返回空响应

- 优点：实现简单，与普通的HTTP请求无异
- 缺点：效率低下，因为即使没有新数据，客户端也会不断发送请求；响应不是实时的；服务器和客户端的开销较大


**长轮询(Long Polling)**

长轮询实对短轮询的改进。客户端发送HTTP请求，服务器保持该请求打开，直到有新数据可用。一旦有新数据，服务器立即发送响应到客户端。客户端处理完响应后立即发起新的请求。

- 优点：比短轮询更即时，因为服务器有数据立即发送。
- 缺点：连接管理复杂，服务器必须能处理大量挂起的请求；客户端仍然需要在处理完一个请求后发送另一个请求


**服务器发送事件(Server-Sent Events, SSE)**

服务器发送事件是一种允许服务器猪东向客户端发送事件的技术。它通过HTTP连接发送流式更新，连接通常保持打开，以便服务器可以随时发送新数据

- 优点：与HTTP协议兼容；服务器可以主动发送消息；连接为单向，只能服务器到客户端
- 缺点：浏览器支持度不足；通信仅限于文本数据；单向通信，客户端需要使用另外的方式发送到服务器


**WebSocket**

WebSocket提供一个全双工通信渠道，客户端和服务器可以通过建立的连接互相发送数据，连接建立后可以保持开放状态，直到任一方关闭连接

- 优点：全双工通信，可以同时发送和接收消息；更高效，减少了HTTP的开销
- 缺点：相对复杂的协议；需要服务器特别支持；更高的资源需求(对服务器)以维持连接


**综合对比**

- 实时性：WebSocket为最实时，其次是长轮询和SSE，短轮询实时性最差
- 开销和效率：WebSocket性能最高，长轮询和SSE在特定情况下表现良好，短轮询开销最大且效率低下
- 实现复杂性：WebSocket和SSE实现起来比短轮询和长轮询复杂
- 浏览器支持：短/长轮询在所有浏览器中得到支持，而SSE和WebSocket支持度较低，但现代浏览器普遍支持WebSocket

在选择哪种技术来实现即时通讯时，应该根据具体的应用需求、兼容性要求和资源限制来决定。WebSocket通常是实现即时通讯的首选技术，因为它提供了最佳的实时性和效率


